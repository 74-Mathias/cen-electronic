Le 09/11/2014

- Introduce 30F / 32 for cenIO.h
- CompositeOutputStream => Initialize the size of the array from external call and not inside !!
- Logger => Initialize the size of the array from external call and not inside !!

Le 30/06/23014 :

- Eviter que le PIC n'envoie des instructions au Pont en H à l'initialisation
- Remplacer tous les câbles de datas par des connexions blindées !

Le 20/04/2014 :

- Séparer la notion de BSpline pour pouvoir faire une MOTOR_BOARD + compacte (éventuellement uniquement 30F)
- Fusionner la partie GameStrategieBoard
- Gérer le fait qu'une commande ne soit pas comprise (timeout très faible)
- Gérer un numéro de message, et un ack correspondant
- Gérer un checksum au niveau des communications
- Tester massivement les entrées sorties via un onglet spécifique au niveau du programme de contrôle
- Faire une documentation de la partie Logger en UML, ainsi qu'en diagramme de séquence
- Gérer dans un fichier séparé la partie obstacle dans ou hors de la table
- Faire le schéma d'architecture global, en incluant les IOIO Board

P2 
* EZ : Désactiver les TargetActions quand il y a un obstacle
* Gérer la stratégie du robot en fonction de l'adversaire !!!
* Tester intensivement la gestion de collision / blocage de roues

2014

* Informatique
** Documentation
 => SV : Fournir une documentation de la partie PROG-30F
 => SV : Fournir une documentation de la partie Eclipse
** Général
 => SV : Faire un nouveau DriverDataDispatcher spécial UART si c'est possible pour pouvoir relier des cartes en UART en maitre esclave :) 

** MainBoard 
  => SV : Améliorer la vitesse d'écriture sur le LCD / centraliser les delay(5)
  => SV : Faire le ménage au niveau des fichiers c : robotDetector.c
  => SV : Harmoniser la gestion des Sonars / GP2D12 notamment la gestion du filtrage / distance (tableaux, seuils)
  => SV : Séparer le RobotSonarDetectorDevice de la partie non Device

** MotorBoard
 => SV : Carte moteur : Gestion de l'arrêt des moteurs pour éviter d'usiner la table
 => SV : Evitement à améliorer et à mettre sur la MainBoard
 => SV : Faire la gestion de la manoeuvre de recalibrage 
 => SV : Implémenter et tester la gestion de l'enchainement des trajectoires, primitive de gestion d'obstacle
 => SV : Mettre en place une patte en dur sur la motor Board à change d'état lors de la gestion des obstacle
 
** Strategy Board
 => SV : En cas d'obstacle, la 1ère des choses est de reculer un peu
 => SV : Optimiser le calcul de changement de stratégie si le robot en face n'a pas changer
 => SV : Info de placement dans les TargetAction
 => SV : Améliorer le mode pas à pas

** Eclipse
 => SV : Faire fonctionner la stratégie au niveau du projet Eclipse
 => SV : Installer GIT sur la carte mère embarquée du PC
 => SV : Mode PAS à PAS à faire au niveau de l'informatique
 => SV : Faire un générateur de code Java => C++ pour résoudre le problème de partage
de la stratégie. => Faire un éditeur graphique de stratégie

* Electronique
** PIC32
 => JJ : Faire une carte de prototype remplaçant à terme la LCD
** Soudure
 => JJ : Mettre absolument de la soudure sur toutes les pattes où il y a potentiellement un cavalier

* Mecanique
 => Structure du carter arrière : Mettre les cartes sur du Velcro
 => SV : Voir fixation : http://wiki.droids-corp.org/index.php/Microb_Technology/2009/Mechanics/bloc_moteur
 => SV : Faire des supports de balises à hauteur pour les tests d'évitements
 => SV : Prévoir air comprimé pour nettoyer les contacts

 Mise en place du RESET GLOBAL

AUTRES :

- Idées pour l'année prochaine :

ACHATS à FAIRE

- Petits Colliers
- Contacteurs grandes lames
- Connecteurs vierges de 3 pattes pour Servo, ADC ...
- Capteurs de couleurs
